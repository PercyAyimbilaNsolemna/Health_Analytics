QUESTION: 30-Day Readmission Rate

SQL QUERY:

WITH inpatient_encounters AS (
    SELECT
        e.encounter_id,
        e.patient_id,
        e.provider_id,
        e.discharge_date,
        LEAD(e.encounter_date) OVER (
            PARTITION BY e.patient_id
            ORDER BY e.encounter_date
        ) AS next_encounter_date,
        LEAD(e.encounter_type) OVER (
            PARTITION BY e.patient_id
            ORDER BY e.encounter_date
        ) AS next_encounter_type
    FROM encounters e
    WHERE e.encounter_type = 'Inpatient'
    AND e.discharge_date IS NOT NULL
)
SELECT
    s.specialty_name,
    COUNT(*) AS total_discharges,
    SUM(
        CASE
            WHEN next_encounter_type = 'Inpatient'
            AND next_encounter_date <= discharge_date + INTERVAL 30 DAY
            THEN 1
            ELSE 0
        END
    ) AS readmissions,
    ROUND(
        SUM(
            CASE
                WHEN next_encounter_type = 'Inpatient'
                AND next_encounter_date <= discharge_date + INTERVAL 30 DAY
                THEN 1
                ELSE 0
            END
        ) / COUNT(*) * 100, 2
    ) AS readmission_rate_percent
FROM inpatient_encounters ie
JOIN providers p
    ON ie.provider_id = p.provider_id
JOIN specialties s
    ON p.specialty_id = s.specialty_id
GROUP BY
    s.specialty_name
ORDER BY
    readmission_rate_percent DESC;

SCHEMA ANALYSIS:

TABLES JOINED: encounters (in CTE), providers, specialties

NUMBER OF JOINS: 2 (plus window function operations)

PERFORMANCE:

ESTIMATED EXECUTION TIME: 0.24 ms

ESTIMATED ROWS SCANNED: 59 (Detailed access types analysis in the notebook)

ESTIMATED QUERY COST: 13.84

BOTTLENECK IDENTIFIED:
1. Full Table Scan on encounters
    [Step 1] Table scan on e

    Meaning of the bottleneck

    1. MySQL is reading every row in the encounters table.

    2. It does this before filtering for inpatient encounters.

    Why this bottleneck matters

    1. With many rows, scanning the entire table is slow.

    2. This happens because the database cannot quickly jump to inpatient rows.

2. Sorting for Window Functions
    [Step 3] Sort: e.patient_id, e.encounter_date

    What this means

    1. To use LEAD(), MySQL must:

        Group rows by patient

        Sort encounters by date

    Why this is a bottleneck

    1. Sorting is expensive

    2. Sorting gets slower as rows increase

    3. Sorting cannot be skipped for window functions